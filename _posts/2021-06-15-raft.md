---
layout: post
title: Raft 
date: 2021-06-15
tags: MIT-6.824 
---
# Introduction 
&ensp;&ensp;Raft is a consensus algorithm for managing a replicated log. Consensus algorithms allow a collection of machines to work as a coherent group that can survive the failures of some of its members.
# Replicated state machines
&ensp;&ensp;Consensus algorithms typically arise in the context of replicated state machines. Replicated state machines are typically implemented using a replicated log, as shown in Figure 1.
![](/images/posts/raft_fig1.png) 

&ensp;&ensp;Consensus algorithms for practical systems typically have the following properties:
- 1.They ensure safety (never returning an incorrect result) under all non-Byzantine conditions, including network delays, partitions, and packet loss, duplication, and reordering.
- 2.They are fully functional (available) as long as any majority of the servers are operational and can communicate with each other and with clients. Thus, a typical cluster of five servers can tolerate the failure of any two servers.
- 3.They do not depend on timing to ensure the consistency of the logs: faulty clocks and extreme message delays can, at worst, cause availability problems.
- 4.In the common case, a command can complete as soon as a majority of the cluster has responded to a single round of remote procedure calls; a minority of slow servers need not impact overall system performance.

# The Raft consensus algorithm
&ensp;&ensp;Raft is an algorithm for managing a replicated log described above. [Figure 2](https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf) summarizes the algorithm in condensed form for reference, and Figure 3 lists key properties of the algorithm.
![](/images/posts/raft_fig3.png) 
&ensp;&ensp;Raft implements consensus by first electing a distinguished leader, then giving the leader complete responsibility for managing the replicated log. The leader accepts log entries from clients, replicates them on other servers, and tells servers when it is safe to apply log entries to their state machines. A leader can fail or become disconnected from the other servers, in which case a new leader is elected.

&ensp;&ensp;Given the leader approach, Raft decomposes the consensus problem into three relatively independent subproblems:
- 1.**Leader election**: a new leader must be chosen when an existing leader fails. 
- 2.**Log replication**: the leader must accept log entries from clients and replicate them across the cluster, forcing the other logs to agree with its own.
- 3.**Safety**: the key safety property for Raft is the State Machine Safety Property in Figure 3: if any server has applied a particular log entry to its state machine, then no other server may apply a different command for the same log index.

## 1. Raft basics 
&ensp;&ensp;A Raft cluster contains several servers; five is a typical number, which allows the system to tolerate two failures. At any given time each server is in one of three states: leader, follower, or candidate. In normal operation there is exactly one leader and all of the other servers are followers. Followers are passive: they issue no requests on their own but simply respond to requests from leaders and candidates. The leader handles all client requests (if a client contacts a follower, the follower redirects it to the leader). The third state, candidate, is used to elect a new leader. Figure 4 shows the states and their transitions. 
![](/images/posts/raft_fig4.png) 

&ensp;&ensp;Raft divides time into terms of arbitrary length, as shown in Figure 5. Terms act as a logical clock  in Raft, and they allow servers to detect obsolete information such as stale leaders. Each server stores a current term number, which increases monotonically over time. Current terms are exchanged whenever servers communicate; if one server’s current term is smaller than the other’s, then it updates its current term to the larger value. If a candidate or leader discovers that its term is out of date, it immediately reverts to follower state. If a server receives a request with a stale term number, it rejects the request.
![](/images/posts/raft_fig5.png) 

&ensp;&ensp;Raft servers communicate using remote procedure calls (RPCs), and the basic consensus algorithm requires only two types of RPCs. **RequestVote RPCs** are initiated by candidates during elections, and **AppendEntries RPCs** are initiated by leaders to replicate log entries and to provide a form of heartbeat. Raft adds a third RPC for **transferring snapshots** between servers. Servers retry RPCs if they do not receive a response in a timely manner, and they issue RPCs in parallel for best performance.

## 2. Leader election
&ensp;&ensp;Raft uses a heartbeat mechanism to trigger leader election. When servers start up, they begin as followers. A server remains in follower state as long as it receives valid RPCs from a leader or candidate. Leaders send periodic heartbeats (AppendEntries RPCs that carry no log entries) to all followers in order to maintain their authority. If a follower receives no communication over a period of time
called the election timeout, then it assumes there is no viable leader and begins an election to choose a new leader.

&ensp;&ensp;To begin an election, a follower increments its current term and transitions to candidate state. It then votes for itself and issues RequestVote RPCs in parallel to each of the other servers in the cluster. A candidate continues in this state until one of three things happens: (a) it wins the election, (b) another server establishes itself as leader, or (c) a period of time goes by with no winner.

&ensp;&ensp;A candidate wins an election if it receives votes from a majority of the servers in the full cluster for the same term.  Once a candidate wins an election, it becomes leader. It then sends heartbeat messages to all of the other servers to establish its authority and prevent new elections.

&ensp;&ensp;While waiting for votes, a candidate may receive an AppendEntries RPC from another server claiming to be leader. If the leader’s term (included in its RPC) is at least as large as the candidate’s current term, then the candidate recognizes the leader as legitimate and returns to follower state. If the term in the RPC is smaller than the candidate’s current term, then the candidate rejects the RPC and continues in candidate state.

&ensp;&ensp;The third possible outcome is that a candidate neither wins nor loses the election: if many followers become candidates at the same time, votes could be split so that no candidate obtains a majority. When this happens, each candidate will time out and start a new election by incrementing its term and initiating another round of RequestVote RPCs. However, without extra measures split votes could repeat indefinitely.

&ensp;&ensp;Raft uses randomized election timeouts to ensure that split votes are rare and that they are resolved quickly. To prevent split votes in the first place, election timeouts are chosen randomly from a fixed interval (e.g., 150–300ms). This spreads out the servers so that in most cases only a single server will time out; it wins the election and sends heartbeats before any other servers time out. The same mechanism is used to handle split votes. Each candidate restarts its randomized election timeout at the start of an election, and it waits for that timeout to elapse before starting the next election; this reduces the likelihood of another split vote in the new election. 
