---
layout: post
title: Lab 2 
date: 2021-06-19
tags: MIT-6.824 
---
# Introduction
本实验将实现一个容错的 键/值 存储系统。在这个实验中将实现Raft，一个复制状态机协议。在下一个实验，你将在Raft的基础上构建一个 键/值 服务。然后，你将在多个复制的状态机上“分片”你的服务以获得更高的性能。

通过将一台服务器的状态复制到多个副本服务器上可以达到容错的目的。这样做使得即使某些服务器出现故障也不会影响整体的服务，而挑战在于故障可能导致副本保存的内容不同。

Raft将客户机的请求组织成一个序列，并称之为'log'，并且保证所有的服务器都能看到同样的log。每一个服务器以log上记录的顺序执行客户请求，并将它们应用到本地的服务器状态上。由于所有的服务器执行相同的操作，所以所有的服务器会有相同的状态。如果一个服务器出现故障但稍后恢复，Raft会负责更新其'log'。只要服务器中的大多数仍然在工作，Raft就会继续操作； 但是如果服务器中的大多数都出现故障而无法正常工作，Raft就不会有进一步的执行。

在本实验中，把Raft看做一个Go对象，并实现它的一些方法。多个Raft实例通过RPC实现相互通信，共同维护'log'。你的Raft将支持无限长的命令序列，即'log entries'，这些entries用索引进行编号，且最终会被提交到'log'。

主要的思路可以参照[In Search of an Understandable Consensus Algorithm(Extended Version)](https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf)中的Figure 2。实现的内容主要是保存服务器的状态信息，并在服务器故障时根据状态信息重启服务器。

# The code
通过修改raft/raft.go来完成实验。以下是一些接口的介绍:
```go
// create a new Raft server instance:
rf := Make(peers, me, persister, applyCh)

// start agreement on a new log entry:
rf.Start(command interface{}) (index, term, isleader)

// ask a Raft for its current term, and whether it thinks it is leader
rf.GetState() (term, isLeader)

// each time a new entry is committed to the log, each Raft peer
// should send an ApplyMsg to the service (or tester).
type ApplyMsg
```
调用 Make(peers, me,...) 来创建一个Raft实例。

Start(command) 使 Raft 实例将 command 加入到 log，且 Start(...) 不需要等到 log 添加完成后再返回。

对于每一个新提交的 log entry，每一个副本服务器都应该发送一个 ApplyMsg 给 Make(...) 中的 applyCh。

raft.go 中包含了发送 RPC(sendRequestVote()) 和处理 RPC(RequestVote()) 的示例。本实验应该使用Go的 (src/labrpc) 实现RPC。

# Part 2A: leader election
## Task
实现 Raft 的 leader election 以及 heartbeats(AppendEntries RPCs with no log entries)。

Part 2A的目标是:

对于被选出的 leader, 如果没有失效，它仍然是 leader；如果 old leader 失效，就重新选取一个 new leader。

## Hint

- 参考 Figure 2 中接收和发送RPC，选举，以及与选举有关的状态的部分。

- 将选举状态加入``` Raft struct```，还需要定义一个结构体保存``` log entry ```的信息。

- 填写``` RequestVoteArgs struct ``` 和 ``` RequestVoteReply struct ```。

- 改写``` Make() ```, 创建一个后台 goroutine, 从而在本服务器没有从别的服务器接收到信息时，可以通过发送 RequestVote RPCs 周期性的唤醒新一轮 leader election, 这样就可以使服务器知道谁是 leader。

- 实现``` RequestVote() ``` RPC handler，这样服务器就可以进行投票。

- 为了实现 heartbeats，定义一个``` AppendEntries RPC struct ```, 并且 leader 会周期性的发送它，且不超过10次/秒。

- 写一个``` AppendEntries RPC handler ``` 方法重置 election timeout， 这样当一个服务器被选为 leader 时， 其他服务器就不会被选为 leader。 

- 确保不同服务器的 election timeouts 不会在同一时间触发。换种说法就是：所有服务器都只为自己投票，但是没有谁会成为 leader。

- 在 old leader 失效5秒之内，new leader 就应该被选出。leader election 也许会有很多轮，因为可能出现 split vote。必须选择足够短的 election timeout（以及 heartbeat），这样即使选举需要多轮，也很可能在不到五秒的时间内完成。论文中Section 5.2 提到了election timeouts 一般设置为150-300毫秒，但是本实验中应该比这个范围大一些，具体设置为多少？

- 实现周期性：最简单的方式是创建一个 goroutine，在循环中调用``` time.Sleep() ```。(参见``` Make() ```为此目的创建的``` ticker() goroutine ```)

- 实现``` GetState() ```

- tester 在永久关闭实例时调用 Raft 的 rf.Kill() 。 你可以使用 rf.killed() 检查是否已调用 Kill()。 你可能希望在所有循环中都这样做，以避免 dead Raft 实例打印令人困惑的信息。

- Go RPC 只发送名称以大写字母开头的结构体字段。子结构还必须具有大写的字段名称（例如数组中的 log 记录字段）。labgob 包会警告你这一点；不要忽略警告。


<u>Reference:</u>

[raft](http://thesecretlivesofdata.com/raft/)
