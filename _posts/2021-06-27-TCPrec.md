---
layout: post
title: Lab 2 the TCP receiver 
date: 2021-06-27
tags: CS144 
---
# Overview
在Lab 0中，你实现了一个字节流(ByteStream)。

在Lab 1中，你创建了一个StreamReassembler，它接受一个子串序列(这些序列全部来自同一字节流)，并且将它们重组放回原来的字节流。

这些模块将证明在你的 TCP 实现中很有用，但它们中没有任何内容具体到 TCP 的细节。那些现在改变了。在Lab 2，你将实现 TCPReceiver，是 TCP 实现的一部分，它处理传入的字节流。TCPReceiver 负责在传入的 TCP segments(通过 Internet 传输的数据报的有效载荷) 和传入的 byte stream 之间翻译。

这里继续使用上个实验的示意图。
![](/images/posts/TCP.png) 
TCPReceiver 接受来自Internet的segments(通过segment_received()方法)并且将它们转变为对你的 StreamReassembler 的调用，这些调用最终写入传入的 ByteStream。正如你在 Lab0 中所做的，通过从 TCPSocket 读取。

除了写入传入的流，TCPReceiver 负责告诉 sender 两件事：

- 第一个没有组装的字节的索引，叫做 'acknowledgment number' 或者 'ackno'。这是 receiver 从 sender 接收到的第一个字节。

- 第一个没有组装的索引和第一个没有接受的索引之间的距离叫做 'window size'。

而且，'ackno' 和 'window size' 描述符描述 receiver 的窗口：TCP sender 被允许发送一系列的索引。使用窗口，receiver 可以控制传入的数据流，使得 sender 限制发送，直到 receiver 准备更多。我们有时将 ackno 看做窗口的左边缘(TCPReceiver的最小索引)，而且 ackno+window size 作为右边缘(超过TCPReceiver的最大索引)。

你已经做了大多数的算法工作，包括当你写 StreamReassembler 和 ByteStream 时实现的 TCPReceiver； 这个 lab 将要写一些涉及 TCP 细节的通用类。最难的部分将包括思考 TCP 如何在流中表示每一个字节的位置--也就是 'sequence number'。 

# The TCP Receiver

TCP 是一个协议, 它通过不可靠的数据报可靠地传递一对flow-controlled字节流(每个方向一个)。两端参与TCP连接，并且每一端在同一时刻都既可当'sender'(outgoing byte-stream)又可当'receiver'(incoming byte-stream)。这两端被叫做连接的'endpoints'或者'peers'。

你将实现TCP的'receiver'，负责接收TCP segments(实际的数据报负载)，重新组装字节流(包括它的结束)，并且决定是否因为acknowledgment 和 flow control而把signals送回到sender。

```
这些signals对于TCP提供flow-controlled的能力十分重要，可以使字节流可靠地通过一个不可靠的数据报网络。

在 TCP 中，acknowledgment 意味着："receiver需要的下一个字节的索引是多少，这样receiver可以在ByteStream中组装更多?" 。这告诉sender它需要发送或者重新发送的字节。

Flow control 意味着："receiver感兴趣或者希望收到的索引范围是多少？"。这告诉sender它被允许去发送多少。
```

## Translating between 64-bit indexes and 32-bit seqnos

&ensp;&ensp;We’ll need to implement TCP’s way of representing indexes. We have created a StreamReassembler that reassembles substrings where each individual byte has a 64-bit stream index, with the first byte in the stream always having index zero. A 64-bit index is big enough that we can treat it as never overflowing.In the TCP headers, however, space is precious, and each byte’s index in the stream is represented not with a 64-bit index but with a 32-bit “sequence number,” or “seqno.” This adds three complexities:

- 1.<strong>Your implementation needs to plan for 32-bit integers to wrap around.</strong> Streams in TCP can be arbitrarily long—there’s no limit to the length of a ByteStream that can be sent over TCP. But 2^32 bytes is only 4 GiB, which is not so big. Once a 32-bit sequence number counts up to 2^32 − 1, the next byte in the stream will have the sequence number zero.

- 2.<strong>TCP sequence numbers start at a random value:</strong> To improve security and avoid getting confused by old segments belonging to earlier connections between the same endpoints, TCP tries to make sure sequence numbers can’t be guessed and are unlikely to repeat. So the sequence numbers for a stream don’t start at zero. The first sequence number in the stream is a random 32-bit number called the Initial Sequence Number (ISN). This is the sequence number that represents the SYN (beginning of stream). The rest of the sequence numbers behave normally after that: the first byte of data will have the sequence number of the ISN+1 (mod 2^32), the second byte will have the ISN+2 (mod 2^32), etc.

- 3.<strong>The logical beginning and ending each occupy one sequence number: </strong>In addition to ensuring the receipt of all bytes of data, TCP makes sure that the beginning and ending of the stream are received reliably. Thus, in TCP the SYN (beginning-ofstream) and FIN (end-of-stream) control flags are assigned sequence numbers. Each of these occupies one sequence number. (The sequence number occupied by the SYN flag is the ISN.) Each byte of data in the stream also occupies one sequence number. Keep in mind that SYN and FIN aren’t part of the stream itself and aren’t "bytes" — they represent the beginning and ending of the byte stream itself.

&ensp;&ensp;These sequence numbers (seqnos) are transmitted in the header of each TCP segment. (And, again, there are two streams — one in each direction. Each stream has separate sequence numbers and a different random ISN.) It’s also sometimes helpful to talk about the concept of an “absolute sequence number” (which always starts at zero and doesn’t wrap), and about a “stream index” (what you’ve already been using with your StreamReassembler: an index for each byte in the stream, starting at zero).

&ensp;&ensp;To make these distinctions concrete, consider the byte stream containing just the three-letter string ‘cat’. If the SYN happened to have seqno 2^32 − 2, then the seqnos, absolute seqnos, and stream indices of each byte are:
![](/images/posts/TCP1.png) 
&ensp;&ensp;The figure shows the three different types of indexing involved in TCP:
![](/images/posts/TCP2.png) 

### Todo
&ensp;&ensp;We’ve defined the type for you and provided some helper functions (see wrapping_integers.hh), but you’ll implement the conversions in wrapping_integers.cc:
```c++
    
    // Convert absolute seqno → seqno. Given an absolute sequence number (n) and an Initial Sequence Number (isn), produce the (relative) sequence number for n.
    WrappingInt32 wrap(uint64_t n, WrappingInt32 isn)

    // Convert seqno → absolute seqno. Given a sequence number (n), the Initial Sequence Number (isn), and an absolute checkpoint sequence number, compute the absolute sequence number that corresponds to n that is closest to the checkpoint.
    uint64_t unwrap(WrappingInt32_n, WrappingInt32 isn, uint64_t checkpoint)
```
&ensp;&ensp;Hint:The cleanest/easiest implementation will use the helper functions provided in wrapping_integers.hh. The wrap/unwrap operations should preserve offsets—two seqnos that differ by 17 will correspond to two absolute seqnos that also differ by 17.

&ensp;&ensp;You can test your implementation by running the WrappingInt32 tests. From the build directory, run 

```
ctest -R wrap 
```

## Implementing the TCP receiver
&ensp;&ensp;In the rest of this lab, you’ll be implementing the TCPReceiver.

&ensp;&ensp;It will 

- 1.receive segments from its peer; 

- 2.reassemble the ByteStream using your StreamReassembler;

- 3.calculate the acknowledgment number (ackno) and the window size.  The ackno and window size will eventually be transmitted back to the peer in an outgoing segment.

&ensp;&ensp;First, please review the format of a TCP segment. This is the message that the two endpoints send each other; it is the payload of the lower-level datagrams. The non-grayed-out fields represent the information that’s of interest in this lab: the sequence number, the payload, and the SYN and FIN flags. These are the fields that are written by the sender, and read and acted on by the receiver.
![](/images/posts/TCP3.png) 

&ensp;&ensp;The TCPSegment class represents this message in C++. 

&ensp;&ensp;Next, let’s talk about the interface that your TCPReceiver will provide:
```c++

// Construct a `TCPReceiver` that will store up to `capacity` bytes
TCPReceiver(const size_t capacity); // implemented for you in .hh file

// Handle an inbound TCP segment
void segment_received(const TCPSegment &seg);

// The ackno that should be sent to the peer
//
// returns empty if no SYN has been received
//
// This is the beginning of the receiver's window, or in other words,
// the sequence number of the first byte in the stream
// that the receiver hasn't received.
std::optional<WrappingInt32> ackno() const;

// The window size that should be sent to the peer
//
// Formally: this is the size of the window of acceptable indices
// that the receiver is willing to accept. It's the distance between
// the ``first unassembled'' and the ``first unacceptable'' index.
//
// In other words: it's the capacity minus the number of bytes that the
// TCPReceiver is holding in the byte stream.
size_t window_size() const;

// number of bytes stored but not yet reassembled
size_t unassembled_bytes() const; // implemented for you in .hh file

// Access the reassembled byte stream
ByteStream &stream_out(); // implemented for you in .hh file

```

### Todo
&ensp;&ensp;The TCPReceiver is built around your StreamReassembler. We’ve implemented the constructor and the unassembled bytes and stream out methods for you in the .hh file. Here’s what you’ll have to do for the others:

#### 1.segment_received()

&ensp;&ensp;This is the main workhorse method. TCPReceiver::segment received() will be called each time a new segment is received from the peer.

&ensp;&ensp;This method needs to:
- <strong>Set the Initial Sequence Number if necessary.</strong> The sequence number of the first arriving segment that has the SYN flag set is the initial sequence number. You’ll want to keep track of that in order to keep converting between 32-bit wrapped seqos/acknos and their absolute equivalents. (Note that the SYN flag is just one flag in the header. The same segment could also carry data and could even have the FIN flag set.)

- <strong>Push any data, or end-of-stream marker, to the StreamReassembler.</strong> If the FIN flag is set in a TCPSegment’s header, that means that the last byte of the payload is the last byte of the entire stream. Remember that the StreamReassembler expects stream indexes starting at zero; you will have to unwrap the seqnos to produce these.

#### 2.ackno()

&ensp;&ensp;Returns an optional<WrappingInt32> containing the sequence number of the first byte that the receiver doesn’t already know. This is the windows’s left edge: the first byte the receiver is interested in receiving. If the ISN hasn’t been set yet, return an empty optional.

#### 3.window_size()
&ensp;&ensp;Returns the distance between the “first unassembled” index (the index corresponding to the ackno) and the “first unacceptable” index.

## Evolution of the TCPReceiver over the life of the connections
&ensp;&ensp;Over the course of a TCP connection, your TCPReceiver will evolve through a sequence of states: from waiting for a SYN (with empty ackno), to an in-progress stream, to a stream that’s finished, meaning input has ended on the ByteStream. The test suite will check that your TCPReceiver correctly handles incoming TCPSegments and evolves through these states, as shown below. (You don’t have to worry about the error state or the RST flag until Lab 4.)
![](/images/posts/TCP4.png) 

## Development and debugging advice
- Implement the TCPReceiver’s public interface (and any private methods or functions you’d like) in the file <strong>tcp receiver.cc</strong>. You may add any private members you like to the TCPReceiver class in tcp <strong>receiver.hh</strong>.

- Test your code with 
``` 
$ make format
$ make
$ make check_lab2 
```

# Solution

## Translating between 64-bit indexes and 32-bit seqnos

### code

```c++

// 64bit -> 32bit
// 思路：序列号的起点 + 偏移
// 序列号的起点就是isn
// 偏移则是 (n-0) % (2^32)
// 所以最后的结果是： isn + n % mod 
WrappingInt32 wrap(uint64_t n, WrappingInt32 isn) { 
    uint64_t mod = 1ul << 32; 
    n = n % mod; 
    return isn + static_cast<uint32_t>(n); 
} 

// 32bit -> 64bit
// 思路：绝对序列号的起点 + 偏移
// 1.首先找到距离checkpoint最近的2^32的倍数, 记为closetCheckpoint, 比如0，2^32, 2^33, 2^34....
// 2.然后计算偏移 offset = n-isn，
//   如果offset < 2^31，则closestCheckpoint是绝对序列号中的起点，
//   否则，closetCheckpoint-mod 是绝对序列号中的起点；
//   还有一种特殊情况，如果closestCheckpoint == 0, closestCheckpoint 只能是绝对序列号中的起点。
//   所以最后结果是: 绝对序列号的起点 + offset
uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) { 
     // DUMMY_CODE(n, isn, checkpoint); 
     uint64_t mod = 1ul << 32; 
     uint64_t closestCheckpoint = (checkpoint + (1ul << 31)) / mod * mod; 
     uint64_t res = 0; 
     uint64_t offset = n.raw_value() - isn.raw_value(); 
      
     if (closestCheckpoint == 0) { 
         return offset; 
     } 
     if (offset < (1ll << 31)) { 
         res = closestCheckpoint + offset; 
     } else { 
         res = closestCheckpoint - mod + offset; 
     } 
  
     return res; 
} 

```

### result
![](/images/posts/TCP5.png) 

<u>Reference:</u>
[lab2](https://cs144.github.io/assignments/lab2.pdf)
